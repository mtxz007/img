[TOC]

## 一、Redis 知识全景图

“两大维度，三大主线”：两大维度”就是指系统维度和应用维度，“三大主线”也就是指高性能、高可靠和高可扩展

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\两大维度三大主线.jfif)

Redis问题画像图：

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\Redis问题画像图.jfif)

## 二、全局哈希表

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。

一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。因为这个哈希表保存了所有的键值对，所以，我也把它称为**全局哈希表**。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\全局哈希表.jfif)

Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指**同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接**。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\哈希表的哈希冲突.jfif)

### 2.1 rehash

为了避免某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低，所以会进行rehash操作：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。

Redis 采用了**渐进式 rehash**。简单来说就是在拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\渐进式rehash.jfif)

在 rehash 被触发后，即使没有收到新请求，Redis 也会定时执行一次 rehash 操作，而且，每次执行时长不会超过 1ms，以免对其他任务造成影响。

**触发rehash的时机：**

Redis 会使用装载因子（load factor）来判断是否需要做 rehash。装载因子的计算方式是，哈希表中所有 entry 的个数除以哈希表的哈希桶个数。Redis 会根据装载因子的两种情况，来触发 rehash 操作：

+ 装载因子≥1，同时，哈希表被允许进行 rehash；在进行 RDB 生成和 AOF 重写时，哈希表的 rehash 是被禁止的，这是为了避免对 RDB 和 AOF 重写造成影响。如果此时，Redis 没有在生成 RDB 和重写 AOF，那么，就可以进行 rehash。
+ 装载因子≥5；表明当前保存的数据量已经远远大于哈希桶的个数，哈希桶里会有大量的链式哈希存在，性能会受到严重影响，此时，就立马开始做 rehash。

## 三、AOF日志

AOF日志(Append Only File)是**写后日志**，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志，好处：

+ 避免额外的检查开销，只有命令能执行成功，才会被记录到日志中。
+ 在命令执行后才记录日志，所以**不会阻塞当前的写操作**。

以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。

### 3.1 三种写回策略

+ **Always**，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
+ **Everysec**，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
+ **No**，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

### 3.2 AOF 重写机制

重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。

重写的过程总结为“**一个拷贝，两处日志**”。

**“一个拷贝”**就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，**第一处日志**就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。

**第二处日志**，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\AOF非阻塞的重写过程.jfif)

**AOF重写过程中潜在的其他风险：**

风险一：Redis 主线程 fork 创建 bgrewriteaof 子进程时，内核需要创建用于管理子进程的相关数据结构，这些数据结构在操作系统中通常叫作进程控制块（Process Control Block，简称为 PCB）。内核要把主线程的 PCB 内容拷贝给子进程。这个创建和拷贝过程由内核执行，是会阻塞主线程的。而且，在拷贝过程中，子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork 执行时间就会长，这就会给主线程带来阻塞风险。

风险二：bgrewriteaof 子进程会和主线程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。因为操作系统在分配内存空间时，有查找和锁的开销，这就会导致阻塞。

## 四、RDB快照

把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件(Redis DataBase)。

进行bgsave时，Redis 就会借助操作系统提供的**写时复制技术**（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。

此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\写时复制机制保证快照期间数据可修改.jfif)

Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

```bash
# "REDIS"开头，AOF结尾
aof-use-rdb-preamble yes
```

### 4.1 写时复制

对 Redis 来说，主线程 fork 出 bgsave 子进程后，bgsave 子进程实际是复制了主线程的页表。这些页表中，就保存了在执行 bgsave 命令时，主线程的所有数据块在内存中的物理地址。这样一来，bgsave 子进程生成 RDB 时，就可以根据页表读取这些数据，再写入磁盘中。如果此时，主线程接收到了新写或修改操作，那么，主线程会使用写时复制机制。具体来说，写时复制就是指，主线程在有写操作时，才会把这个新写或修改后的数据写入到一个新的物理地址中，并修改自己的页表映射。

bgsave 子进程复制主线程的页表以后，假如主线程需要修改虚页 7 里的数据，那么，主线程就需要新分配一个物理页（假设是物理页 53），然后把修改后的虚页 7 里的数据写到物理页 53 上，而虚页 7 里原来的数据仍然保存在物理页 33 上。这个时候，虚页 7 到物理页 33 的映射关系，仍然保留在 bgsave 子进程中。所以，bgsave 子进程可以无误地把虚页 7 的原始数据写入 RDB 文件。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\写时复制底层机制.jfif)

## 五、主线程、子进程和后台线程

Redis 启动以后，本身就是一个进程，它会接收客户端发送的请求，并处理读写操作请求。而且，接收请求和处理请求操作是 Redis 的主要工作，Redis 没有再依赖于其他线程，所以，我一般把完成这个主要工作的 Redis 进程，称为**主进程**或**主线程**。

在主线程中，我们还可以使用 fork 创建子进程，或是使用 pthread_create 创建线程。Redis 中用 fork 创建的子进程：

+ 创建 RDB 的后台子进程，同时由它负责在主从同步时传输 RDB 给从库；
+ 通过无盘复制方式传输 RDB 的子进程；
+ bgrewriteaof 子进程。

从 4.0 版本开始，Redis 也开始使用 pthread_create 创建线程，这些线程在创建后，一般会自行执行一些任务，例如执行异步删除任务。相对于完成主要工作的主线程来说，我们一般可以称这些线程为后台线程。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\Redis主线程子进程和后台进程.jfif)

## 六、实例阻塞点

### 6.1 4大类交互对象和5大阻塞点

Redis 实例交互的对象，以及交互时会发生的操作：

+ **客户端**：网络 IO，键值对增删改查操作，数据库操作；
+ **磁盘**：生成 RDB 快照，记录 AOF 日志，AOF 日志重写；
+ **主从节点**：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；
+ **切片集群实例**：向其他实例传输哈希槽信息，数据迁移。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\Redis交互对象和具体的操作.jfif)

会引起阻塞的的操作：

1. 和客户端交互时的阻塞点：**集合全量查询和聚合操作**，**bigkey 删除操作**，**清空数据库**。
2. 和磁盘交互时的阻塞点：**AOF 日志同步写**。
3. 主从节点交互时的阻塞点：清空数据库，**加载 RDB 文件**。
4. 切片集群实例交互时的阻塞点：没有 bigkey 时，切片集群的各实例在进行交互时不会阻塞主线程。

### 6.2 异步的子线程机制

对于 Redis 的五大阻塞点来说，除了“集合全量查询和聚合操作”和“从库加载 RDB 文件”，其他三个阻塞点涉及的操作都不需要给客户端返回具体的数据结果，所以，我们可以使用 Redis 的**异步子线程机制**来实现 bigkey 删除，清空数据库，以及 AOF 日志同步写。

Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。

主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。

但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此，我们把这种异步删除也称为惰性删除（lazy free）。此时，删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\异步子线程执行机制.jfif)

异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能，Redis 也提供了新的命令来执行这两个操作：

+ 键值对删除：当你的集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，可以使用 UNLINK 命令。
+ 清空数据库：可以在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC 选项，这样就可以让后台子线程异步地清空数据库。

对于无法使用异步操作来完成的操作建议：

+ 集合全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算；
+ 从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。

## 七、响应延迟排查

判断 Redis 是不是真的变慢了：

+ 查看 Redis 的响应延迟。
+ 基于当前环境下的 Redis 基线性能做判断：redis-cli 命令提供了–intrinsic-latency 选项，可以用来监测和统计测试期间内的最大延迟，这个延迟可以作为 Redis 的基线性能。一般情况下，运行 120 秒就足够监测到最大延迟了，把运行时延迟和基线性能进行对比，如果你观察到的 Redis 运行时延迟是其基线性能的 2 倍及以上，就可以认定 Redis 变慢了。

影响 Redis 性能的**三大要素**：**Redis 自身的操作特性、文件系统和操作系统**。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\影响 Redis 性能的三大要素.jfif)

### 7.1 Redis 自身操作特性

**1. 慢查询命令**：

根据请求对应的具体命令以及官方文档，确认下是否采用了复杂度高的慢查询命令。如果的确有大量的慢查询命令，有两种处理方式：

- **用其他高效命令代替**。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成线程阻塞。

+ **当需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例**。

**2. 过期 key 操作**：

Redis 键值对的 key 可以设置过期时间。默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下：

1. 采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的 key 全部删除；
2. 如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。

**当频繁使用带有相同时间参数的 EXPIREAT 命令设置过期 key**，就会导致在同一秒内有大量的 key 同时过期，从而触发算法2，Redis 的线程就会一直执行删除，这样一来，就没办法正常服务其他的键值操作了，就会进一步引起其他键值操作的延迟增加，Redis 就会变慢。

### 7.2 文件系统：AOF 模式

AOF 日志提供了三种日志写回策略：no、everysec、always。这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。write 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；而 fsync 需要把日志记录写回到磁盘后才能返回，时间较长。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\AOF三种写回策略.jfif)

当写回策略配置为 everysec 和 always 时，Redis 需要调用 fsync 把日志写回磁盘。但是，这两种写回策略的具体执行情况还不太一样。

+ 在使用 everysec 时，Redis 允许丢失一秒的操作记录，所以，Redis 主线程并不需要确保每个操作记录日志都写回磁盘。而且，fsync 的执行时间很长，如果是在 Redis 主线程中执行 fsync，就容易阻塞主线程。所以，当写回策略配置为 everysec 时，Redis 会使用后台的子线程异步完成 fsync 的操作。
+ 对于 always 策略来说，Redis 需要确保每个操作记录日志都写回磁盘，如果用后台子线程异步完成，主线程就无法及时地知道每个操作是否已经完成了，这就不符合 always 策略的要求了。所以，always 策略并不使用后台子线程来执行。

另外，Redis 使用子进程来进行 AOF 重写，但有一个潜在的风险点：AOF 重写会对磁盘进行大量 IO 操作，同时，fsync 又需要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被阻塞。

当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。所以，如果后台子线程执行的 fsync 频繁阻塞的话（比如 AOF 重写占用了大量的磁盘 IO 带宽），主线程也会阻塞，导致 Redis 性能变慢。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\fsync 后台子线程和主线程受到的影响.jfif)

如果业务应用对延迟非常敏感，但同时允许一定量的数据丢失，那么，可以把配置项 `no-appendfsync-on-rewrite` 设置为 yes，表示在 AOF 重写时，不进行 fsync 操作(宕机数据丢失)。

### 7.3 操作系统

#### swap

内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发 swap，无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。

与 AOF 日志文件读写使用 fsync 线程不同，swap 触发后影响的是 Redis 主 IO 线程，这会极大地增加 Redis 的响应时间。

触发 swap 的原因主要是**物理机器内存不足**，对于 Redis 而言，有两种常见的情况：

+ Redis 实例自身使用了大量的内存，导致物理机器的可用内存不足；
+ 和 Redis 实例在同一台机器上运行的其他进程，在进行大量的文件读写操作。文件读写本身会占用系统内存，这会导致分配给 Redis 实例的内存量变少，进而触发 Redis 发生 swap。

#### 内存大页

除了内存 swap，还有一个和内存相关的因素，即内存大页机制（Transparent Huge Page, THP），也会影响 Redis 性能。

虽然内存大页可以给 Redis 带来内存分配方面的收益，但是，Redis 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，此时，Redis 主线程仍然可以接收客户端写请求。客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，Redis 就会采用**写时复制机制**，也就是说，一旦有数据要被修改，Redis 并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。

当客户端请求修改或新写入数据较多时，内存大页机制将导致大量的拷贝，这就会影响 Redis 正常的访存操作，最终导致性能变慢。

### 7.4 排查方法

1. 获取 Redis 实例在当前环境下的基线性能。
2. 是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。
   + 分析：a) 查看slowlog是否存在这些命令；b) Redis进程CPU使用率是否飙升（聚合运算命令导致）
   + 解决：a) 不使用复杂度过高的命令，或用其他方式代替实现（放在客户端做） b) 数据尽量分批查询（LRANGE key 0 N，建议N<=100，查询全量数据建议使用HSCAN/SSCAN/ZSCAN）
3. 是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除。
   + 分析：a) 业务使用EXPIREAT/PEXPIREAT命令 b) Redis info中的expired_keys指标短期突增
   + 解决：a) 优化业务，过期增加随机时间，把时间打散，减轻删除过期key的压力 b) 运维层面，监控expired_keys指标，有短期突增及时报警排查
4. 是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。
   + 分析：a) slowlog出现很多SET/DELETE变慢命令（bigkey分配内存和释放内存变慢） b) 使用redis-cli -h $host -p $port --bigkeys扫描出很多bigkey
   + 解决：a) 优化业务，避免存储bigkey b) Redis 4.0+可开启lazy-free机制
5. Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。
   + 分析：磁盘IO负载变高
   + 解决：a) 使用everysec机制 b) 丢失数据不敏感的业务不开启AOF
6. 生成RDB和AOF重写fork耗时严重
   + 分析：a) Redis变慢只发生在生成RDB和AOF重写期间 b) 实例占用内存越大，fork拷贝内存页表越久 c) Redis info中latest_fork_usec耗时变长
   + 解决：a) 实例尽量小 b) Redis尽量部署在物理机上 c) 优化备份策略（例如低峰期备份） d) 合理配置repl-backlog和slave client-output-buffer-limit，避免主从全量同步 e) 视情况考虑关闭AOF f) 监控latest_fork_usec耗时是否变长
7. Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况。
   + 分析：a) 实例内存达到maxmemory，且写入量大，淘汰key压力变大 b) Redis info中的evicted_keys指标短期突增
   + 解决：a) 业务层面，根据情况调整淘汰策略（随机比LRU快） b) 运维层面，监控evicted_keys指标，有短期突增及时报警 c) 集群扩容，多个实例减轻淘汰key的压力
   + 使用swap分析：a) 所有请求全部开始变慢 b) slowlog大量慢日志 c) 查看Redis进程是否使用到了Swap
   + 解决：a) 增加机器内存 b) 集群扩容 c) Swap使用时监控报警
8. 大量短连接请求
   + 分析：Redis处理大量短连接请求，TCP三次握手和四次挥手也会增加耗时
   + 解决：使用长连接操作Redis
9. 在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。
   + 分析：生成RDB和AOF重写期间，主线程处理写请求耗时变长（拷贝内存副本耗时变长）
   + 解决：关闭透明大页机制
10. 是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。
11. 是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。
    + 分析：a) Redis进程只绑定一个CPU逻辑核 b) NUMA架构下，网络中断处理程序和Redis进程没有绑定在同一个Socket下
    + 解决：a) Redis进程绑定多个CPU逻辑核 b) 网络中断处理程序和Redis进程绑定在同一个Socket下
12. 网卡负载过高
    + 分析：a) TCP/IP层延迟变大，丢包重传变多 b) 是否存在流量过大的实例占满带宽
    + a) 机器网络资源监控，负载过高及时报警 b) 提前规划部署策略，访问量大的实例隔离部署

## 八、内存碎片

内存碎片的形成有内因和外因两个层面的原因。简单来说，内因是操作系统的内存分配机制，外因是 Redis 的负载特征。

### 8.1 内因

**内存分配器的分配策略**

Redis 可以使用 libc、jemalloc、tcmalloc 多种内存分配器来分配内存，默认使用 jemalloc。jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如 8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB 等。当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间。

### 8.2 外因

**键值对大小不一样和删改操作**

+ Redis 通常作为共用的缓存系统或键值数据库对外提供服务，所以，不同业务应用的数据都可能保存在 Redis 中，这就会带来不同大小的键值对。这样一来，Redis 申请内存空间分配时，本身就会有大小不一的空间需求。
+ 键值对会被修改和删除，导致空间的扩容和释放，造成的内存空间变化。

### 8.3 判断内存碎片率

Redis 自身提供了 INFO 命令，可以用来查询内存使用的详细信息，命令如下：

```bash
INFO memory
# Memory
used_memory:1073741736			# Redis 为了保存数据实际申请使用的空间
used_memory_human:1024.00M
used_memory_rss:1997159792		# 操作系统实际分配给 Redis 的物理内存空间
used_memory_rss_human:1.86G
…
mem_fragmentation_ratio:1.86	# used_memory_rss/ used_memory
```

+ **mem_fragmentation_ratio 大于 1 但小于 1.5**。这种情况是合理的。这是因为，刚才我介绍的那些因素是难以避免的。毕竟，内因的内存分配器是一定要使用的，分配策略都是通用的，不会轻易修改；而外因由 Redis 负载决定，也无法限制。所以，存在内存碎片也是正常的。
+ **mem_fragmentation_ratio 大于 1.5** 。这表明内存碎片率已经超过了 50%。一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。
+ **mem_fragmentation_ratio 小于1**。这表明操作系统分配给Redis进程的物理内存，要小于Redis实际存储数据的内存，也就是说Redis没有足够的物理内存可以使用了，这会导致Redis一部分内存数据会被换到Swap中，之后当Redis访问Swap中的数据时，延迟会变大，性能下降。碎片率低并非只跟SWAP有关，复制积压缓冲区配置较大、业务数据量较小的情况下极容易造成碎片率远低于1，[参考](https://cloud.tencent.com/developer/article/1986604)。

### 8.4 清理内存碎片

当 Redis 发生内存碎片后，一个“简单粗暴”的方法就是**重启 Redis 实例**。当然，这并不是一个“优雅”的方法，毕竟，重启 Redis 会带来两个后果：

+ 如果 Redis 中的数据没有持久化，那么，数据就会丢失；
+ 即使 Redis 数据持久化了，我们还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。

从 4.0-RC3 版本以后，Redis 自身提供了一种**内存碎片自动清理**的方法，不过，**碎片清理是有代价的**，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为 Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。而且，有的时候，数据拷贝还需要注意顺序，会进一步增加 Redis 的等待时间，导致性能降低。

自动内存碎片清理机制在控制碎片清理启停的时机上，既考虑了碎片的空间占比、对 Redis 内存使用效率的影响，还考虑了清理机制本身的 CPU 时间占比、对 Redis 性能的影响。自动清理相关参数：

```bash
# 启用自动清理功能
activedefrag yes

# 内存碎片的字节数达到 100MB 时开始清理
active-defrag-ignore-bytes 100mb

# 内存碎片空间占操作系统分配给 Redis 的总空间比例达到 10% 时开始清理
active-defrag-threshold-lower 10

# 自动清理过程所用 CPU 时间的比例不低于 25%，保证清理能正常开展
active-defrag-cycle-min 25

# 自动清理过程所用 CPU 时间的比例不高于 75%，一旦超过，就停止清理，
# 从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高。
active-defrag-cycle-max 75
```

## 九、缓冲区

### 9.1 客户端输入输出缓冲区

为了避免客户端和服务器端的请求发送和处理速度不匹配，服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区，称之为客户端输入缓冲区和输出缓冲区。

**输入缓冲区**就是用来暂存客户端发送的请求命令的，所以可能导致溢出的情况主要是下面两种：

+ 写入了 bigkey，比如一下子写入了多个百万级别的集合类型数据；
+ 服务器端处理请求的速度过慢，例如，Redis 主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。

要查看和服务器端相连的每个客户端对输入缓冲区的使用情况，我们可以**使用 CLIENT LIST 命令**：

```bash
127.0.0.1:6379> client list
id=5 addr=127.0.0.1:50487 fd=9 name= age=4 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client
```

与输入缓冲区相关的三个参数：

+ cmd，表示客户端最新执行的命令。这个例子中执行的是 CLIENT 命令。
+ qbuf，表示输入缓冲区已经使用的大小。这个例子中的 CLIENT 命令已使用了 26 字节大小的缓冲区。
+ qbuf-free，表示输入缓冲区尚未使用的大小。这个例子中的 CLIENT 命令还可以使用 32742 字节的缓冲区。qbuf 和 qbuf-free 的总和就是，Redis 服务器端当前为已连接的这个客户端分配的缓冲区总大小。这个例子中总共分配了 26 + 32742 = 32768 字节，也就是 32KB 的缓冲区。

避免输入缓冲区溢出：

+ Redis 的客户端输入缓冲区大小的上限阈值，在代码中就设定为了 1GB，不能调整。
+ 避免客户端写入 bigkey，以及避免 Redis 主线程阻塞。

Redis 的**输出缓冲区**暂存的是 Redis 主线程要返回给客户端的数据。每个客户端设置的输出缓冲区也包括两部分：一部分，是一个大小为 16KB 的固定缓冲空间，用来暂存 OK 响应和出错信息；另一部分，是一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。发生输出缓冲区溢出的情况：

+ 服务器端返回 bigkey 的大量结果；
+ 执行了 MONITOR 命令；
+ 缓冲区大小设置得不合理。

可以通过 `client-output-buffer-limit` 配置项，来设置缓冲区的大小。具体设置的内容包括两方面：

+ 设置缓冲区大小的上限阈值；
+ 设置输出缓冲区持续写入数据的数量上限阈值，和持续写入数据的时间的上限阈值。

```bash
# 给普通客户端设置缓冲区大小
# 对于普通客户端来说，它每发送完一个请求，会等到请求结果返回后，再发送下一个请求，这种发送方式称为阻塞式发送。
# 在这种情况下，如果不是读取体量特别大的 bigkey，服务器端的输出缓冲区一般不会被阻塞的。
client-output-buffer-limit normal 0 0 0

# 给订阅客户端设置缓冲区大小
# 对于订阅客户端来说，一旦订阅的 Redis 频道有消息了，服务器端都会通过输出缓冲区把消息发给客户端。
# 所以，订阅客户端和服务器间的消息发送方式，不属于阻塞式发送。不过，如果频道消息较多的话，也会占用较多的输出缓冲区空间。
client-output-buffer-limit pubsub 8mb 2mb 60
```

应对输出缓冲区溢出：

+ 避免 bigkey 操作返回大量数据结果；
+ 避免在线上环境中持续使用 MONITOR 命令。
+ 使用 `client-output-buffer-limit` 设置合理的缓冲区大小上限，或是缓冲区连续写入时间和写入量上限。

### 9.2 主从集群中的缓冲区

主从集群间的数据复制包括全量复制和增量复制两种。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。无论在哪种形式的复制中，为了保证主从节点的数据一致，都会用到缓冲区。

在**全量复制**过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等 RDB 文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\主从全量复制中的缓冲区.jfif)

如果在全量复制时，从节点接收和加载 RDB 较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。

避免复制缓冲区发生溢出：

+ 控制主节点保存的数据量大小：把主节点的数据量控制在 2~4GB，可以让全量同步执行得更快些，避免复制缓冲区累积过多命令。
+ 使用 `client-output-buffer-limit `配置项，依据主节点的数据量大小、主节点的写负载压力和主节点本身的内存大小来设置复制缓冲区大小。

```bash
# 给主节点设置缓冲区大小
client-output-buffer-limit slave 512mb 128mb 60
```

假设一条写命令数据是 1KB，那么，复制缓冲区可以累积 512K 条（512MB/1KB = 512K）写命令。同时，主节点在全量复制期间，可以承受的写命令速率上限是 2000 条 /s（128MB/1KB/60 约等于 2000）。

**增量复制**时使用的缓冲区称为**复制积压缓冲区**。

主节点在把接收到的写命令同步给从节点时，同时会把这些写命令写入复制积压缓冲区。一旦从节点发生网络闪断，再次和主节点恢复连接后，从节点就会从复制积压缓冲区中，读取断连期间主节点接收到的写命令，进而进行增量同步：

![image-20230621134835744](C:\Users\Huawei\Documents\Typora\img\复制积压缓冲区.jfif)

复制积压缓冲区是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。为了应对复制积压缓冲区的溢出问题，我们可以调整复制积压缓冲区的大小，也就是设置 `repl_backlog_size` 这个参数的值。

`repl_backlog_size`参数大小和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl_backlog_size = 缓冲空间大小 * 2。

### 9.3 小结

从缓冲区溢出对 Redis 的影响的角度，这四个缓冲区可以分成两类做个总结。

+ 缓冲区溢出导致网络连接关闭：普通客户端、订阅客户端，以及从节点客户端，它们使用的缓冲区，本质上都是 Redis 客户端和服务器端之间，或是主从节点之间为了传输命令数据而维护的。这些缓冲区一旦发生溢出，处理机制都是直接把客户端和服务器端的连接，或是主从节点间的连接关闭。网络连接关闭造成的直接影响，就是业务程序无法读写 Redis，或者是主从节点全量同步失败，需要重新执行。
+ 缓冲区溢出导致命令数据丢失：主节点上的复制积压缓冲区属于环形缓冲区，一旦发生溢出，新写入的命令数据就会覆盖旧的命令数据，导致旧命令数据的丢失，进而导致主从节点重新进行全量复制。

缓冲区溢出原因：命令数据发送过快过大；命令数据处理较慢；缓冲区空间过小。

应对方案：

+ 针对命令数据发送过快过大的问题，对于普通客户端来说可以避免 bigkey，而对于复制缓冲区来说，就是避免过大的 RDB 文件。
+ 针对命令数据处理较慢的问题，解决方案就是减少 Redis 主线程上的阻塞操作，例如使用异步的删除操作。
+ 针对缓冲区空间过小的问题，解决方案就是使用 `client-output-buffer-limit` 配置项设置合理的输出缓冲区、复制缓冲区和复制积压缓冲区大小。另外，输入缓冲区的大小默认是固定的，我们无法通过配置来修改它，除非直接去修改 Redis 源码。

